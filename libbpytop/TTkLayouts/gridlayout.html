<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>TermTk.TTkLayouts.gridlayout API documentation</title>
<meta name="description" content="Grid Layout
[Tutorial](https://github.com/ceccopierangiolieugenio/pyTermTk/blob/main/tutorial/002-layout.md) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>TermTk.TTkLayouts.gridlayout</code></h1>
</header>
<section id="section-intro">
<h3 id="grid-layout">Grid Layout</h3>
<p><a href="https://github.com/ceccopierangiolieugenio/pyTermTk/blob/main/tutorial/002-layout.md">Tutorial</a></p>
<p>The grid layout allows an automatic place all the widgets in a grid
the empty rows/cols are resized to the "columnMinHeight,columnMinWidth" parameters</p>
<pre><code>TTkGridLayout        ┌┐ columnMinWidth
 ╔═════════╤═════════╤╤═════════╗
 ║ Widget1 │ Widget2 ││ Widget3 ║
 ║ (0,0)   │ (0,1)   ││ (0,3)   ║
 ╟─────────┼─────────┼┼─────────╢ ┐ columnMinHeight
 ╟─────────┼─────────┼┼─────────╢ ┘
 ║ Widget4 │         ││         ║
 ║ (2,0)   │         ││         ║
 ╟─────────┼─────────┼┼─────────╢
 ║         │         ││ Widget5 ║
 ║         │         ││ (3,3)   ║
 ╚═════════╧═════════╧╧═════════╝
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

# MIT License
#
# Copyright (c) 2021 Eugenio Parodi &lt;ceccopierangiolieugenio AT googlemail DOT com&gt;
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

&#39;&#39;&#39;
### Grid Layout
[Tutorial](https://github.com/ceccopierangiolieugenio/pyTermTk/blob/main/tutorial/002-layout.md)

The grid layout allows an automatic place all the widgets in a grid
the empty rows/cols are resized to the &#34;columnMinHeight,columnMinWidth&#34; parameters

    TTkGridLayout        ┌┐ columnMinWidth
     ╔═════════╤═════════╤╤═════════╗
     ║ Widget1 │ Widget2 ││ Widget3 ║
     ║ (0,0)   │ (0,1)   ││ (0,3)   ║
     ╟─────────┼─────────┼┼─────────╢ ┐ columnMinHeight
     ╟─────────┼─────────┼┼─────────╢ ┘
     ║ Widget4 │         ││         ║
     ║ (2,0)   │         ││         ║
     ╟─────────┼─────────┼┼─────────╢
     ║         │         ││ Widget5 ║
     ║         │         ││ (3,3)   ║
     ╚═════════╧═════════╧╧═════════╝
&#39;&#39;&#39;

from TermTk.TTkCore.constant import TTkK
from TermTk.TTkCore.log import TTkLog
from TermTk.TTkLayouts.layout import TTkLayout, TTkWidgetItem

class TTkGridLayout(TTkLayout):
    __slots__ = (&#39;_gridItems&#39;,&#39;_columnMinWidth&#39;,&#39;_columnMinHeight&#39;)
    def __init__(self, *args, **kwargs):
        &#39;&#39;&#39;
        TTkGridLayout constructor

        Args:
            columnMinWidth (int, optional, default=0): the minimum width of the column
            columnMinHeight (int, optional, default=0): the minimum height of the column
        &#39;&#39;&#39;
        TTkLayout.__init__(self, *args, **kwargs)
        self._gridItems = [[]]
        self._columnMinWidth = kwargs.get(&#39;columnMinWidth&#39;,0)
        self._columnMinHeight = kwargs.get(&#39;columnMinHeight&#39;,0)

    def _gridUsedsize(self):
        rows = 1
        cols = 0
        for gridRow in range(len(self._gridItems)):
            if rows  &lt; gridRow:
                rows = gridRow
            for gridCol in range(len(self._gridItems[0])):
                if self._gridItems[gridRow][gridCol] is not None:
                    if cols &lt; gridCol:
                        cols = gridCol
        return (rows+1, cols+1)

    def _reshapeGrid(self, size):
        rows = size[0]
        cols = size[1]

        # remove extra rows
        if   rows &lt; len(self._gridItems):
            self._gridItems = self._gridItems[:rows]
        elif rows &gt; len(self._gridItems):
            self._gridItems += [None]*(rows-len(self._gridItems))
        # remove extra cols
        for gridRow in range(len(self._gridItems)):
            if self._gridItems[gridRow] is None:
                self._gridItems[gridRow] = [None]*(cols)
                continue
            sizeRow = len(self._gridItems[gridRow])
            if cols &lt; sizeRow:
                self._gridItems[gridRow] = self._gridItems[gridRow][:cols]
            elif cols &gt; sizeRow:
                self._gridItems[gridRow] += [None]*(cols-sizeRow)

    # addWidget(self, widget, row, col)
    def addWidget(self, *args, **kwargs):
        widget = args[0]
        self.removeWidget(widget)
        item = TTkWidgetItem(widget=widget)
        if len(args) == 3:
            TTkGridLayout.addItem(self, item, args[1], args[2])
        else:
            TTkGridLayout.addItem(self, item)
        widget.update()

    def replaceItem(self, item, index): pass

    def addItem(self, *args, **kwargs):
        item = args[0]
        self.removeItem(item)
        if len(args) == 3:
            row = args[1]
            col = args[2]
        else:
            # Append The widget at the end
            row = 0
            col = len(self._gridItems[0])

        #retrieve the max col/rows to reshape the grid
        maxrow = row
        maxcol = col
        for child in self.children():
            if maxrow &lt; child._row: maxrow = child._row
            if maxcol &lt; child._col: maxcol = child._col
        # reshape the gridItems
        maxrow += 1
        maxcol += 1

        # TODO: This is RUBBISH!!!
        self._reshapeGrid(size=(maxrow,maxcol))
        if self._gridItems[row][col] is not None:
            # TODO: Handle the LayoutItem
            self.removeItem(self._gridItems[row][col])
        self._reshapeGrid(size=(maxrow,maxcol))

        item._row = row
        item._col = col
        self._gridItems[row][col] = item
        TTkLayout.addItem(self, item)

    def removeItem(self, item):
        TTkLayout.removeItem(self, item)
        for gridRow in range(len(self._gridItems)):
            for gridCol in range(len(self._gridItems[0])):
                if self._gridItems[gridRow][gridCol] == item:
                    self._gridItems[gridRow][gridCol] = None
        self._reshapeGrid(self._gridUsedsize())

    def removeWidget(self, widget):
        TTkLayout.removeWidget(self, widget)
        for gridRow in range(len(self._gridItems)):
            for gridCol in range(len(self._gridItems[0])):
                if self._gridItems[gridRow][gridCol] is not None and \
                   self._gridItems[gridRow][gridCol].layoutItemType == TTkK.WidgetItem and \
                   self._gridItems[gridRow][gridCol].widget() == widget:
                    self._gridItems[gridRow][gridCol] = None
        self._reshapeGrid(self._gridUsedsize())

    def itemAtPosition(self, row: int, col: int):
        if row &gt;= len(self._gridItems) or \
           col &gt;= len(self._gridItems[0]):
            return None
        return self._gridItems[row][col]

    def minimumColWidth(self, gridCol: int) -&gt; int:
        colw = 0
        anyItem = False
        for gridRow in range(len(self._gridItems)):
            item = self._gridItems[gridRow][gridCol]
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    w = item.minimumWidth()
                    if colw &lt; w:
                        colw = w
        if not anyItem:
            return self._columnMinWidth
        return colw

    def minimumRowHeight(self, gridRow: int):
        rowh = 0
        anyItem = False
        for item in self._gridItems[gridRow]:
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    h = item.minimumHeight()
                    if rowh &lt; h:
                        rowh = h
        if not anyItem:
            return self._columnMinHeight
        return rowh

    def maximumColWidth(self, gridCol: int) -&gt; int:
        colw = 0x10000
        anyItem = False
        for gridRow in range(len(self._gridItems)):
            item = self._gridItems[gridRow][gridCol]
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    w = item.maximumWidth()
                    if colw &gt; w:
                        colw = w
        if not anyItem:
            return self._columnMinWidth
        return colw

    def maximumRowHeight(self, gridRow: int):
        rowh = 0x10000
        anyItem = False
        for item in self._gridItems[gridRow]:
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    h = item.maximumHeight()
                    if rowh &gt; h:
                        rowh = h
        if not anyItem:
            return self._columnMinHeight
        return rowh

    def minimumWidth(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        minw = 0
        for gridCol in range(len(self._gridItems[0])):
            minw += self.minimumColWidth(gridCol)
        return minw

    def minimumHeight(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        minh = 0
        for gridRow in range(len(self._gridItems)):
            minh += self.minimumRowHeight(gridRow)
        return minh

    def maximumWidth(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        if not self._gridItems[0]:
            return 0x1000
        maxw = 0
        for gridCol in range(len(self._gridItems[0])):
            maxw += self.maximumColWidth(gridCol)
        return maxw

    def maximumHeight(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        if not self._gridItems[0]:
            return 0x1000
        maxh = 0
        for gridRow in range(len(self._gridItems)):
            maxh += self.maximumRowHeight(gridRow)
        return maxh


    def update(self, *args, **kwargs):
        x, y, w, h = self.geometry()
        newx, newy = x, y

        # Sorted List of minimum heights
        #                    min                        max                       val
        #  content IDs     0 1                          2                         3
        sortedHeights = [ [i, self.minimumRowHeight(i), self.maximumRowHeight(i), -1] for i in range(len(self._gridItems)) ]
        sortedWidths  = [ [i, self.minimumColWidth(i),  self.maximumColWidth(i),  -1] for i in range(len(self._gridItems[0])) ]
        sortedHeights = sorted(sortedHeights, key=lambda h: h[1])
        sortedWidths  = sorted(sortedWidths,  key=lambda w: w[1])

        minWidth = 0
        minHeight = 0
        for i in sortedWidths:  minWidth  += i[1]
        for i in sortedHeights: minHeight += i[1]

        if h &lt; minHeight: h = minHeight
        if w &lt; minWidth:  w = minWidth

        #TTkLog.debug(f&#34;w,h:({w,h}) mh:{minHeight} sh:{sortedHeights}&#34;)
        #TTkLog.debug(f&#34;w,h:({w,h}) mw:{minWidth}  sw:{sortedWidths}&#34;)

        def parseSizes(sizes, space, out):
            iterate = True
            freeSpace = space
            leftSlots = len(sizes)
            while iterate and leftSlots &gt; 0:
                iterate = False
                for item in sizes:
                    if item[3] != -1: continue
                    if freeSpace &lt; 0: freeSpace=0
                    sliceSize = freeSpace//leftSlots
                    mins = item[1]
                    maxs = item[2]
                    if sliceSize &gt;= maxs:
                        iterate = True
                        freeSpace -= maxs
                        leftSlots -= 1
                        item[3] = maxs
                    elif sliceSize &lt; mins:
                        iterate = True
                        freeSpace -= mins
                        leftSlots -= 1
                        item[3] = mins
            # Push the sizes
            for item in sizes:
                out[item[0]] = [0,item[3]]
                if item[3] == -1:
                    sliceSize = freeSpace//leftSlots
                    out[item[0]] = [0,sliceSize]
                    freeSpace -= sliceSize
                    leftSlots -= 1

        vertSizes = [None]*len(sortedHeights)
        horSizes  = [None]*len(sortedWidths)
        parseSizes(sortedHeights,h, vertSizes)
        parseSizes(sortedWidths, w, horSizes)

        for i in horSizes:
            i[0] = newx
            newx += i[1]
        for i in vertSizes:
            i[0] = newy
            newy += i[1]

        #TTkLog.debug(f&#34;h:{horSizes} v:{vertSizes}&#34;)

        # loop and set the geometry of any item
        for item in self.children():
            col = item._col
            row = item._row
            item.setGeometry(
                    horSizes[col][0], vertSizes[row][0] ,
                    horSizes[col][1], vertSizes[row][1] )
            #TTkLog.debug(f&#34;Children: {item.geometry()}&#34;)
            if item.layoutItemType == TTkK.WidgetItem and not item.isEmpty():
                #TTkLog.debug(f&#34;Children name: {item.widget()._name}&#34;)
                item.widget().update(*args, **kwargs)
            elif item.layoutItemType == TTkK.LayoutItem:
                item.update(*args, **kwargs)
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout"><code class="flex name class">
<span>class <span class="ident">TTkGridLayout</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>TTkGridLayout constructor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>columnMinWidth</code></strong> :&ensp;<code>int</code>, optional, default=<code>0</code></dt>
<dd>the minimum width of the column</dd>
<dt><strong><code>columnMinHeight</code></strong> :&ensp;<code>int</code>, optional, default=<code>0</code></dt>
<dd>the minimum height of the column</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TTkGridLayout(TTkLayout):
    __slots__ = (&#39;_gridItems&#39;,&#39;_columnMinWidth&#39;,&#39;_columnMinHeight&#39;)
    def __init__(self, *args, **kwargs):
        &#39;&#39;&#39;
        TTkGridLayout constructor

        Args:
            columnMinWidth (int, optional, default=0): the minimum width of the column
            columnMinHeight (int, optional, default=0): the minimum height of the column
        &#39;&#39;&#39;
        TTkLayout.__init__(self, *args, **kwargs)
        self._gridItems = [[]]
        self._columnMinWidth = kwargs.get(&#39;columnMinWidth&#39;,0)
        self._columnMinHeight = kwargs.get(&#39;columnMinHeight&#39;,0)

    def _gridUsedsize(self):
        rows = 1
        cols = 0
        for gridRow in range(len(self._gridItems)):
            if rows  &lt; gridRow:
                rows = gridRow
            for gridCol in range(len(self._gridItems[0])):
                if self._gridItems[gridRow][gridCol] is not None:
                    if cols &lt; gridCol:
                        cols = gridCol
        return (rows+1, cols+1)

    def _reshapeGrid(self, size):
        rows = size[0]
        cols = size[1]

        # remove extra rows
        if   rows &lt; len(self._gridItems):
            self._gridItems = self._gridItems[:rows]
        elif rows &gt; len(self._gridItems):
            self._gridItems += [None]*(rows-len(self._gridItems))
        # remove extra cols
        for gridRow in range(len(self._gridItems)):
            if self._gridItems[gridRow] is None:
                self._gridItems[gridRow] = [None]*(cols)
                continue
            sizeRow = len(self._gridItems[gridRow])
            if cols &lt; sizeRow:
                self._gridItems[gridRow] = self._gridItems[gridRow][:cols]
            elif cols &gt; sizeRow:
                self._gridItems[gridRow] += [None]*(cols-sizeRow)

    # addWidget(self, widget, row, col)
    def addWidget(self, *args, **kwargs):
        widget = args[0]
        self.removeWidget(widget)
        item = TTkWidgetItem(widget=widget)
        if len(args) == 3:
            TTkGridLayout.addItem(self, item, args[1], args[2])
        else:
            TTkGridLayout.addItem(self, item)
        widget.update()

    def replaceItem(self, item, index): pass

    def addItem(self, *args, **kwargs):
        item = args[0]
        self.removeItem(item)
        if len(args) == 3:
            row = args[1]
            col = args[2]
        else:
            # Append The widget at the end
            row = 0
            col = len(self._gridItems[0])

        #retrieve the max col/rows to reshape the grid
        maxrow = row
        maxcol = col
        for child in self.children():
            if maxrow &lt; child._row: maxrow = child._row
            if maxcol &lt; child._col: maxcol = child._col
        # reshape the gridItems
        maxrow += 1
        maxcol += 1

        # TODO: This is RUBBISH!!!
        self._reshapeGrid(size=(maxrow,maxcol))
        if self._gridItems[row][col] is not None:
            # TODO: Handle the LayoutItem
            self.removeItem(self._gridItems[row][col])
        self._reshapeGrid(size=(maxrow,maxcol))

        item._row = row
        item._col = col
        self._gridItems[row][col] = item
        TTkLayout.addItem(self, item)

    def removeItem(self, item):
        TTkLayout.removeItem(self, item)
        for gridRow in range(len(self._gridItems)):
            for gridCol in range(len(self._gridItems[0])):
                if self._gridItems[gridRow][gridCol] == item:
                    self._gridItems[gridRow][gridCol] = None
        self._reshapeGrid(self._gridUsedsize())

    def removeWidget(self, widget):
        TTkLayout.removeWidget(self, widget)
        for gridRow in range(len(self._gridItems)):
            for gridCol in range(len(self._gridItems[0])):
                if self._gridItems[gridRow][gridCol] is not None and \
                   self._gridItems[gridRow][gridCol].layoutItemType == TTkK.WidgetItem and \
                   self._gridItems[gridRow][gridCol].widget() == widget:
                    self._gridItems[gridRow][gridCol] = None
        self._reshapeGrid(self._gridUsedsize())

    def itemAtPosition(self, row: int, col: int):
        if row &gt;= len(self._gridItems) or \
           col &gt;= len(self._gridItems[0]):
            return None
        return self._gridItems[row][col]

    def minimumColWidth(self, gridCol: int) -&gt; int:
        colw = 0
        anyItem = False
        for gridRow in range(len(self._gridItems)):
            item = self._gridItems[gridRow][gridCol]
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    w = item.minimumWidth()
                    if colw &lt; w:
                        colw = w
        if not anyItem:
            return self._columnMinWidth
        return colw

    def minimumRowHeight(self, gridRow: int):
        rowh = 0
        anyItem = False
        for item in self._gridItems[gridRow]:
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    h = item.minimumHeight()
                    if rowh &lt; h:
                        rowh = h
        if not anyItem:
            return self._columnMinHeight
        return rowh

    def maximumColWidth(self, gridCol: int) -&gt; int:
        colw = 0x10000
        anyItem = False
        for gridRow in range(len(self._gridItems)):
            item = self._gridItems[gridRow][gridCol]
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    w = item.maximumWidth()
                    if colw &gt; w:
                        colw = w
        if not anyItem:
            return self._columnMinWidth
        return colw

    def maximumRowHeight(self, gridRow: int):
        rowh = 0x10000
        anyItem = False
        for item in self._gridItems[gridRow]:
            if item is not None and \
               ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                    anyItem = True
                    h = item.maximumHeight()
                    if rowh &gt; h:
                        rowh = h
        if not anyItem:
            return self._columnMinHeight
        return rowh

    def minimumWidth(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        minw = 0
        for gridCol in range(len(self._gridItems[0])):
            minw += self.minimumColWidth(gridCol)
        return minw

    def minimumHeight(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        minh = 0
        for gridRow in range(len(self._gridItems)):
            minh += self.minimumRowHeight(gridRow)
        return minh

    def maximumWidth(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        if not self._gridItems[0]:
            return 0x1000
        maxw = 0
        for gridCol in range(len(self._gridItems[0])):
            maxw += self.maximumColWidth(gridCol)
        return maxw

    def maximumHeight(self) -&gt; int:
        &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
        if not self._gridItems[0]:
            return 0x1000
        maxh = 0
        for gridRow in range(len(self._gridItems)):
            maxh += self.maximumRowHeight(gridRow)
        return maxh


    def update(self, *args, **kwargs):
        x, y, w, h = self.geometry()
        newx, newy = x, y

        # Sorted List of minimum heights
        #                    min                        max                       val
        #  content IDs     0 1                          2                         3
        sortedHeights = [ [i, self.minimumRowHeight(i), self.maximumRowHeight(i), -1] for i in range(len(self._gridItems)) ]
        sortedWidths  = [ [i, self.minimumColWidth(i),  self.maximumColWidth(i),  -1] for i in range(len(self._gridItems[0])) ]
        sortedHeights = sorted(sortedHeights, key=lambda h: h[1])
        sortedWidths  = sorted(sortedWidths,  key=lambda w: w[1])

        minWidth = 0
        minHeight = 0
        for i in sortedWidths:  minWidth  += i[1]
        for i in sortedHeights: minHeight += i[1]

        if h &lt; minHeight: h = minHeight
        if w &lt; minWidth:  w = minWidth

        #TTkLog.debug(f&#34;w,h:({w,h}) mh:{minHeight} sh:{sortedHeights}&#34;)
        #TTkLog.debug(f&#34;w,h:({w,h}) mw:{minWidth}  sw:{sortedWidths}&#34;)

        def parseSizes(sizes, space, out):
            iterate = True
            freeSpace = space
            leftSlots = len(sizes)
            while iterate and leftSlots &gt; 0:
                iterate = False
                for item in sizes:
                    if item[3] != -1: continue
                    if freeSpace &lt; 0: freeSpace=0
                    sliceSize = freeSpace//leftSlots
                    mins = item[1]
                    maxs = item[2]
                    if sliceSize &gt;= maxs:
                        iterate = True
                        freeSpace -= maxs
                        leftSlots -= 1
                        item[3] = maxs
                    elif sliceSize &lt; mins:
                        iterate = True
                        freeSpace -= mins
                        leftSlots -= 1
                        item[3] = mins
            # Push the sizes
            for item in sizes:
                out[item[0]] = [0,item[3]]
                if item[3] == -1:
                    sliceSize = freeSpace//leftSlots
                    out[item[0]] = [0,sliceSize]
                    freeSpace -= sliceSize
                    leftSlots -= 1

        vertSizes = [None]*len(sortedHeights)
        horSizes  = [None]*len(sortedWidths)
        parseSizes(sortedHeights,h, vertSizes)
        parseSizes(sortedWidths, w, horSizes)

        for i in horSizes:
            i[0] = newx
            newx += i[1]
        for i in vertSizes:
            i[0] = newy
            newy += i[1]

        #TTkLog.debug(f&#34;h:{horSizes} v:{vertSizes}&#34;)

        # loop and set the geometry of any item
        for item in self.children():
            col = item._col
            row = item._row
            item.setGeometry(
                    horSizes[col][0], vertSizes[row][0] ,
                    horSizes[col][1], vertSizes[row][1] )
            #TTkLog.debug(f&#34;Children: {item.geometry()}&#34;)
            if item.layoutItemType == TTkK.WidgetItem and not item.isEmpty():
                #TTkLog.debug(f&#34;Children name: {item.widget()._name}&#34;)
                item.widget().update(*args, **kwargs)
            elif item.layoutItemType == TTkK.LayoutItem:
                item.update(*args, **kwargs)
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="TermTk.TTkLayouts.layout.TTkLayout" href="layout.html#TermTk.TTkLayouts.layout.TTkLayout">TTkLayout</a></li>
<li><a title="TermTk.TTkLayouts.layout.TTkLayoutItem" href="layout.html#TermTk.TTkLayouts.layout.TTkLayoutItem">TTkLayoutItem</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="TermTk.TTkLayouts.boxlayout.TTkHBoxLayout" href="boxlayout.html#TermTk.TTkLayouts.boxlayout.TTkHBoxLayout">TTkHBoxLayout</a></li>
<li><a title="TermTk.TTkLayouts.boxlayout.TTkVBoxLayout" href="boxlayout.html#TermTk.TTkLayouts.boxlayout.TTkVBoxLayout">TTkVBoxLayout</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.addItem"><code class="name flex">
<span>def <span class="ident">addItem</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addItem(self, *args, **kwargs):
    item = args[0]
    self.removeItem(item)
    if len(args) == 3:
        row = args[1]
        col = args[2]
    else:
        # Append The widget at the end
        row = 0
        col = len(self._gridItems[0])

    #retrieve the max col/rows to reshape the grid
    maxrow = row
    maxcol = col
    for child in self.children():
        if maxrow &lt; child._row: maxrow = child._row
        if maxcol &lt; child._col: maxcol = child._col
    # reshape the gridItems
    maxrow += 1
    maxcol += 1

    # TODO: This is RUBBISH!!!
    self._reshapeGrid(size=(maxrow,maxcol))
    if self._gridItems[row][col] is not None:
        # TODO: Handle the LayoutItem
        self.removeItem(self._gridItems[row][col])
    self._reshapeGrid(size=(maxrow,maxcol))

    item._row = row
    item._col = col
    self._gridItems[row][col] = item
    TTkLayout.addItem(self, item)</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.addWidget"><code class="name flex">
<span>def <span class="ident">addWidget</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addWidget(self, *args, **kwargs):
    widget = args[0]
    self.removeWidget(widget)
    item = TTkWidgetItem(widget=widget)
    if len(args) == 3:
        TTkGridLayout.addItem(self, item, args[1], args[2])
    else:
        TTkGridLayout.addItem(self, item)
    widget.update()</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.itemAtPosition"><code class="name flex">
<span>def <span class="ident">itemAtPosition</span></span>(<span>self, row: int, col: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itemAtPosition(self, row: int, col: int):
    if row &gt;= len(self._gridItems) or \
       col &gt;= len(self._gridItems[0]):
        return None
    return self._gridItems[row][col]</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumColWidth"><code class="name flex">
<span>def <span class="ident">maximumColWidth</span></span>(<span>self, gridCol: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximumColWidth(self, gridCol: int) -&gt; int:
    colw = 0x10000
    anyItem = False
    for gridRow in range(len(self._gridItems)):
        item = self._gridItems[gridRow][gridCol]
        if item is not None and \
           ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                anyItem = True
                w = item.maximumWidth()
                if colw &gt; w:
                    colw = w
    if not anyItem:
        return self._columnMinWidth
    return colw</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumHeight"><code class="name flex">
<span>def <span class="ident">maximumHeight</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>process the widgets and get the min size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximumHeight(self) -&gt; int:
    &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
    if not self._gridItems[0]:
        return 0x1000
    maxh = 0
    for gridRow in range(len(self._gridItems)):
        maxh += self.maximumRowHeight(gridRow)
    return maxh</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumRowHeight"><code class="name flex">
<span>def <span class="ident">maximumRowHeight</span></span>(<span>self, gridRow: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximumRowHeight(self, gridRow: int):
    rowh = 0x10000
    anyItem = False
    for item in self._gridItems[gridRow]:
        if item is not None and \
           ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                anyItem = True
                h = item.maximumHeight()
                if rowh &gt; h:
                    rowh = h
    if not anyItem:
        return self._columnMinHeight
    return rowh</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumWidth"><code class="name flex">
<span>def <span class="ident">maximumWidth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>process the widgets and get the min size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximumWidth(self) -&gt; int:
    &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
    if not self._gridItems[0]:
        return 0x1000
    maxw = 0
    for gridCol in range(len(self._gridItems[0])):
        maxw += self.maximumColWidth(gridCol)
    return maxw</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumColWidth"><code class="name flex">
<span>def <span class="ident">minimumColWidth</span></span>(<span>self, gridCol: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimumColWidth(self, gridCol: int) -&gt; int:
    colw = 0
    anyItem = False
    for gridRow in range(len(self._gridItems)):
        item = self._gridItems[gridRow][gridCol]
        if item is not None and \
           ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                anyItem = True
                w = item.minimumWidth()
                if colw &lt; w:
                    colw = w
    if not anyItem:
        return self._columnMinWidth
    return colw</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumHeight"><code class="name flex">
<span>def <span class="ident">minimumHeight</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>process the widgets and get the min size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimumHeight(self) -&gt; int:
    &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
    minh = 0
    for gridRow in range(len(self._gridItems)):
        minh += self.minimumRowHeight(gridRow)
    return minh</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumRowHeight"><code class="name flex">
<span>def <span class="ident">minimumRowHeight</span></span>(<span>self, gridRow: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimumRowHeight(self, gridRow: int):
    rowh = 0
    anyItem = False
    for item in self._gridItems[gridRow]:
        if item is not None and \
           ( item.layoutItemType == TTkK.LayoutItem or item.isVisible() ):
                anyItem = True
                h = item.minimumHeight()
                if rowh &lt; h:
                    rowh = h
    if not anyItem:
        return self._columnMinHeight
    return rowh</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumWidth"><code class="name flex">
<span>def <span class="ident">minimumWidth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>process the widgets and get the min size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimumWidth(self) -&gt; int:
    &#39;&#39;&#39; process the widgets and get the min size &#39;&#39;&#39;
    minw = 0
    for gridCol in range(len(self._gridItems[0])):
        minw += self.minimumColWidth(gridCol)
    return minw</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.removeItem"><code class="name flex">
<span>def <span class="ident">removeItem</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeItem(self, item):
    TTkLayout.removeItem(self, item)
    for gridRow in range(len(self._gridItems)):
        for gridCol in range(len(self._gridItems[0])):
            if self._gridItems[gridRow][gridCol] == item:
                self._gridItems[gridRow][gridCol] = None
    self._reshapeGrid(self._gridUsedsize())</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.removeWidget"><code class="name flex">
<span>def <span class="ident">removeWidget</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeWidget(self, widget):
    TTkLayout.removeWidget(self, widget)
    for gridRow in range(len(self._gridItems)):
        for gridCol in range(len(self._gridItems[0])):
            if self._gridItems[gridRow][gridCol] is not None and \
               self._gridItems[gridRow][gridCol].layoutItemType == TTkK.WidgetItem and \
               self._gridItems[gridRow][gridCol].widget() == widget:
                self._gridItems[gridRow][gridCol] = None
    self._reshapeGrid(self._gridUsedsize())</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.replaceItem"><code class="name flex">
<span>def <span class="ident">replaceItem</span></span>(<span>self, item, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replaceItem(self, item, index): pass</code></pre>
</details>
</dd>
<dt id="TermTk.TTkLayouts.gridlayout.TTkGridLayout.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *args, **kwargs):
    x, y, w, h = self.geometry()
    newx, newy = x, y

    # Sorted List of minimum heights
    #                    min                        max                       val
    #  content IDs     0 1                          2                         3
    sortedHeights = [ [i, self.minimumRowHeight(i), self.maximumRowHeight(i), -1] for i in range(len(self._gridItems)) ]
    sortedWidths  = [ [i, self.minimumColWidth(i),  self.maximumColWidth(i),  -1] for i in range(len(self._gridItems[0])) ]
    sortedHeights = sorted(sortedHeights, key=lambda h: h[1])
    sortedWidths  = sorted(sortedWidths,  key=lambda w: w[1])

    minWidth = 0
    minHeight = 0
    for i in sortedWidths:  minWidth  += i[1]
    for i in sortedHeights: minHeight += i[1]

    if h &lt; minHeight: h = minHeight
    if w &lt; minWidth:  w = minWidth

    #TTkLog.debug(f&#34;w,h:({w,h}) mh:{minHeight} sh:{sortedHeights}&#34;)
    #TTkLog.debug(f&#34;w,h:({w,h}) mw:{minWidth}  sw:{sortedWidths}&#34;)

    def parseSizes(sizes, space, out):
        iterate = True
        freeSpace = space
        leftSlots = len(sizes)
        while iterate and leftSlots &gt; 0:
            iterate = False
            for item in sizes:
                if item[3] != -1: continue
                if freeSpace &lt; 0: freeSpace=0
                sliceSize = freeSpace//leftSlots
                mins = item[1]
                maxs = item[2]
                if sliceSize &gt;= maxs:
                    iterate = True
                    freeSpace -= maxs
                    leftSlots -= 1
                    item[3] = maxs
                elif sliceSize &lt; mins:
                    iterate = True
                    freeSpace -= mins
                    leftSlots -= 1
                    item[3] = mins
        # Push the sizes
        for item in sizes:
            out[item[0]] = [0,item[3]]
            if item[3] == -1:
                sliceSize = freeSpace//leftSlots
                out[item[0]] = [0,sliceSize]
                freeSpace -= sliceSize
                leftSlots -= 1

    vertSizes = [None]*len(sortedHeights)
    horSizes  = [None]*len(sortedWidths)
    parseSizes(sortedHeights,h, vertSizes)
    parseSizes(sortedWidths, w, horSizes)

    for i in horSizes:
        i[0] = newx
        newx += i[1]
    for i in vertSizes:
        i[0] = newy
        newy += i[1]

    #TTkLog.debug(f&#34;h:{horSizes} v:{vertSizes}&#34;)

    # loop and set the geometry of any item
    for item in self.children():
        col = item._col
        row = item._row
        item.setGeometry(
                horSizes[col][0], vertSizes[row][0] ,
                horSizes[col][1], vertSizes[row][1] )
        #TTkLog.debug(f&#34;Children: {item.geometry()}&#34;)
        if item.layoutItemType == TTkK.WidgetItem and not item.isEmpty():
            #TTkLog.debug(f&#34;Children name: {item.widget()._name}&#34;)
            item.widget().update(*args, **kwargs)
        elif item.layoutItemType == TTkK.LayoutItem:
            item.update(*args, **kwargs)
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#grid-layout">Grid Layout</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="TermTk.TTkLayouts" href="index.html">TermTk.TTkLayouts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout">TTkGridLayout</a></code></h4>
<ul class="two-column">
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.addItem" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.addItem">addItem</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.addWidget" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.addWidget">addWidget</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.itemAtPosition" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.itemAtPosition">itemAtPosition</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumColWidth" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumColWidth">maximumColWidth</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumHeight" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumHeight">maximumHeight</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumRowHeight" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumRowHeight">maximumRowHeight</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumWidth" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.maximumWidth">maximumWidth</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumColWidth" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumColWidth">minimumColWidth</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumHeight" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumHeight">minimumHeight</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumRowHeight" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumRowHeight">minimumRowHeight</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumWidth" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.minimumWidth">minimumWidth</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.removeItem" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.removeItem">removeItem</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.removeWidget" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.removeWidget">removeWidget</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.replaceItem" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.replaceItem">replaceItem</a></code></li>
<li><code><a title="TermTk.TTkLayouts.gridlayout.TTkGridLayout.update" href="#TermTk.TTkLayouts.gridlayout.TTkGridLayout.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>